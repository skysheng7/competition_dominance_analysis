synch_master_feed2[[i]] <- synch_master_feed[[i]][records_to_keep, ]
# add date
synch_master_cow2[[i]]$date <- date(synch_master_cow2[[i]]$Time)
synch_master_bin2[[i]]$date <- date(synch_master_bin2[[i]]$Time)
synch_master_feed2[[i]]$date <- date(synch_master_feed2[[i]]$Time)
}
return(list(synch_master_cow2 = synch_master_cow2,
synch_master_bin2 = synch_master_bin2,
synch_master_feed2 = synch_master_feed2))
}
process_feed_data <- function(feed_data, total_bin) {
# Set the first row of feed_data if it's NA.
# Use apply to go column by column and replace NA with the first non-NA value.
first_non_na <- apply(feed_data[, 2:(ncol(feed_data) - 1)], 2, function(x) x[which(!is.na(x))[1]])
feed_data[1, 2:(ncol(feed_data) - 1)] <- ifelse(is.na(feed_data[1, 2:(ncol(feed_data) - 1)]), first_non_na, feed_data[1, 2:(ncol(feed_data) - 1)])
# Replace NA values with the last observed non-NA value.
# Do this column by column.
feed_data[, 2:(ncol(feed_data) - 1)] <- apply(feed_data[, 2:(ncol(feed_data) - 1)], 2, na.locf)
# Add a new column calculating the total feed in all bins.
feed_data$totalFeed <- rowSums(feed_data[, 2:(total_bin + 1)], na.rm = TRUE)
return(feed_data)
}
# Call the function
synch_master_feed2 <- process_feed_data(synch_master_feed2, total_bin)
test <- all.fed2[1:2]
View(test)
results <- matrix_process(test, min_feed_bin, max_feed_bin)
feeding_synch_master_cow <- results$synch_master_cow
feeding_synch_master_bin <- results$synch_master_bin
feeding_synch_master_feed <- results$synch_master_feed
View(feeding_synch_master_bin)
View(feeding_synch_master_cow)
View(feeding_synch_master_feed)
View(feeding_synch_master_bin[["2020-07-15"]])
library('ProjectTemplate')
load.project()
library('ProjectTemplate')
load.project()
# Load all packages from library
library(lubridate)
library(plyr)
library(here)
library(zoo)
#library(ggplot2)
test <- all.fed2[1:2]
results <- matrix_process(test, min_feed_bin, max_feed_bin)
feeding_synch_master_cow <- results$synch_master_cow
feeding_synch_master_bin <- results$synch_master_bin
feeding_synch_master_feed <- results$synch_master_feed
View(feeding_synch_master_feed)
View(feeding_synch_master_feed[["2020-07-15"]])
View(all.fed2)
View(all.fed2[["2020-07-15"]])
View(feeding_synch_master_bin)
View(feeding_synch_master_bin[["2020-07-15"]])
View(all.fed2)
View(all.fed2[["2020-07-15"]])
View(all.fed2)
View(all.fed2[["2020-07-15"]])
total_bin <- 30
cur_synch_feed <- feeding_synch_master_feed[[1]]
first_non_na <- apply(cur_synch_feed[, 2:(ncol(cur_synch_feed) - 1)],
2, function(x) x[which(!is.na(x))[1]])
cur_synch_feed[1, 2:(ncol(cur_synch_feed) - 1)] <- ifelse(is.na(cur_synch_feed[1, 2:(ncol(cur_synch_feed) - 1)]),
first_non_na,
cur_synch_feed[1, 2:(ncol(cur_synch_feed) - 1)])
View(cur_synch_feed)
# Replace NA values with the last observed non-NA value.
# Do this column by column.
cur_synch_feed[, 2:(ncol(cur_synch_feed) - 1)] <- apply(cur_synch_feed[, 2:(ncol(cur_synch_feed) - 1)], 2, na.locf)
View(cur_synch_feed)
process_cur_synch_feed <- function(cur_synch_feed, total_bin) {
# Set the first row of cur_synch_feed if it's NA.
# Use apply to go column by column and replace NA with the first non-NA value.
first_non_na <- apply(cur_synch_feed[, 2:(ncol(cur_synch_feed) - 1)],
2, function(x) x[which(!is.na(x))[1]])
cur_synch_feed[1, 2:(ncol(cur_synch_feed) - 1)] <- ifelse(is.na(cur_synch_feed[1, 2:(ncol(cur_synch_feed) - 1)]),
first_non_na,
cur_synch_feed[1, 2:(ncol(cur_synch_feed) - 1)])
# Replace NA values with the last observed non-NA value.
# Do this column by column.
cur_synch_feed[, 2:(ncol(cur_synch_feed) - 1)] <- apply(cur_synch_feed[, 2:(ncol(cur_synch_feed) - 1)], 2, na.locf)
# Add a new column calculating the total feed in all bins.
cur_synch_feed$totalFeed <- rowSums(cur_synch_feed[, 2:(total_bin + 1)], na.rm = TRUE)
return(cur_synch_feed)
}
#' Create a time sequence from start to end, by seconds
#'
#' @param cur_data A data frame containing feeding data, or drinking data or both.
#' @return A vector of time sequence.
create_time_sequence <- function(cur_data) {
total_start <- min(cur_data$Start)
total_end <- max(cur_data$End)
dateTime_seq <- seq(total_start, total_end, by = "sec")
return(dateTime_seq)
}
#' create MATRIX1: empty matrix preperation: CowID X Time for which cow is eating/drinking
#' create a matrix where x axis contains cow ID, and y axis contains time (every seconds)
#'
#' @param cur_data A data frame containing feeding data, or drinking data or both.
#' @param dateTime_seq A vector of time sequence.
#' @return A matrix of Time and cowID.
prepare_time_cow_matrix <- function(cur_data, dateTime_seq) {
cow_list <- sort(unique(cur_data$Cow))
col_num <- length(cow_list) + 1
synch_master_cow <- data.frame(matrix(0, length(dateTime_seq), col_num))
colnames(synch_master_cow) <- c("Time", cow_list)
synch_master_cow$Time <- dateTime_seq
return(synch_master_cow)
}
#' create MARTRIX2: empty matrix preperation: Time X CowID for which bin the cow is at
#'
#' @param cow_time_matrix A matrix of CowID and Time.
#' @return A matrix of Time and CowID.
prepare_time_bin_matrix <- function(cow_time_matrix) {
return(cow_time_matrix)
}
#' create MATRIX3: Time X Bin for how much feed is at each bin at each second
#'
#' @param dateTime_seq A vector of time sequence.
#' @param min_feed_bin Minimum feeder bin value to keep.
#' @param max_feed_bin Maximum feeder bin value to keep.
#' @return A matrix of Time and Feed amount in each bin.
prepare_time_feed_matrix <- function(dateTime_seq, min_feed_bin, max_feed_bin) {
bin_list <- seq(min_feed_bin, max_feed_bin, by = 1)
col_num <- length(bin_list) + 1
synch_master_feed <- data.frame(matrix(NA, length(dateTime_seq), col_num))
colnames(synch_master_feed) <- c("Time", bin_list)
synch_master_feed$Time <- dateTime_seq
return(synch_master_feed)
}
#' Generate empty Synchronization Matrices for Feed/water Data
#'
#' This function takes a list of feed data and creates synchronization matrices for time-cow,
#' time-bin, and time-feed based on each list element.
#'
#' @param data_list A list of feed / water data frames grouped by date.
#' @param min_feed_bin Minimum feeder bin value to keep.
#' @param max_feed_bin Maximum feeder bin value to keep.
#' @return A list containing three lists of matrices:
#'         synch_master_cow, synch_master_bin, synch_master_feed.
empty_synch_matrix <- function(data_list, min_feed_bin, max_feed_bin) {
date_list <- names(data_list)
synch_master_cow <- list()
synch_master_bin <- list()
synch_master_feed <- list()
for (y in 1:length(data_list)) {
cur_data <- data_list[[y]]
cur_data <- cur_data[order(cur_data$Start, cur_data$End), ]
dateTime_seq <- create_time_sequence(cur_data)
cow_time_matrix <- prepare_time_cow_matrix(cur_data, dateTime_seq)
time_bin_matrix <- prepare_time_bin_matrix(cow_time_matrix)
time_feed_matrix <- prepare_time_feed_matrix(dateTime_seq, min_feed_bin, max_feed_bin)
synch_master_cow[[y]] <- cow_time_matrix
synch_master_bin[[y]] <- time_bin_matrix
synch_master_feed[[y]] <- time_feed_matrix
# rename the list name
names(synch_master_cow)[y] <- names(data_list)[y]
names(synch_master_bin)[y] <- names(data_list)[y]
names(synch_master_feed)[y] <- names(data_list)[y]
}
return(list(synch_master_cow = synch_master_cow,
synch_master_bin = synch_master_bin,
synch_master_feed = synch_master_feed))
}
#' Initialize and Process Synchronization Matrices
#'
#' This function initializes synchronization matrices and processes feed/water data
#' to populate the matrices based on each list element.
#' It process MATRIX1 (synch_master_cow): Time X CowID for which cow is eating/drinking
#' AND MARTRIX2 (synch_master_bin): Time X CowID for which bin the cow is at
#' AND MATRIX3 (synch_master_feed): Time X Bin for how much feed/watr is at each bin at each second
#'
#' @param data_list A list of data frames.
#' @param min_feed_bin Minimum value of the feed bin.
#' @param max_feed_bin Maximum value of the feed bin.
#'
#' @return A list containing three matrices:
#'         synch_master_cow, synch_master_bin, synch_master_feed.
matrix_initialize <- function(data_list, min_feed_bin, max_feed_bin) {
results <- empty_synch_matrix(data_list, min_feed_bin, max_feed_bin)
synch_master_cow <- results$synch_master_cow
synch_master_bin <- results$synch_master_bin
synch_master_feed <- results$synch_master_feed
# go through every single day
for (y in 1:length(data_list)) {
cur_data <- data_list[[y]]
cur_data <- cur_data[order(cur_data$Start, cur_data$End), ]
cow_list <- sort(unique(cur_data$Cow))
bin_list <- seq(min_feed_bin, max_feed_bin, by = 1)
### Process MATRIX1 (synch_master_cow): Time X CowID for which cow is eating/drinking
### AND MARTRIX2 (synch_master_bin): Time X CowID for which bin the cow is at
### AND MATRIX3 (synch_master_feed): Time X Bin for how much feed/watr is at each bin at each second
# go through the feed or water datasheet, mark down a "1" on the time, if the cow is feeding/drinking at that second
for (o in 1:nrow(cur_data)) {
cur_cow <- cur_data$Cow[o]
index_cow <- match(cur_cow, cow_list)+1
cur_start <- cur_data$Start[o]
cur_end <- cur_data$End[o]
cur_dur <- cur_data$Duration[o]
cur_bin <- cur_data$Bin[o]
index_bin <- match(cur_bin, bin_list) + 1
start_weight <- cur_data$Startweight[o]
end_weight <- cur_data$Endweight[o]
start_row_number <- which(synch_master_cow[[y]]$Time == cur_start)
end_row_number <- which(synch_master_cow[[y]]$Time == cur_end)
weight_list <- round(seq(start_weight, end_weight, length.out = (end_row_number - start_row_number + 1)), digits = 1)
# process matrix 1, time X CowID on cow
synch_master_cow[[y]][(start_row_number:end_row_number) , index_cow] <- 1
# process matrix 2, time X CowID on bin number
synch_master_bin[[y]][(start_row_number:end_row_number) , index_cow] <- cur_bin
# process matrix 3, time X Bin
synch_master_feed[[y]][(start_row_number:end_row_number), index_bin] <- weight_list
}
}
return(list(synch_master_cow = synch_master_cow,
synch_master_bin = synch_master_bin,
synch_master_feed = synch_master_feed))
}
#' Process the current synchronization data to replace NA values and compute total feed
#'
#' This function processes the provided `cur_synch` data matrix.
#' It replaces the initial NA values of each column with the first non-NA value in that column.
#' Then, it replaces any subsequent NA values in each column with the last observed non-NA value in that column.
#' Finally, it calculates the total feed in all bins and adds it as a new column.
#'
#' @param cur_synch A matrix/dataframe representing the current synchronization data.
#'                  The first column is expected to be 'Time', and the other columns represent bins.
#'                  The matrix should have NA values where feed data is not available.
#' @param total_bin An integer indicating the total number of bins.
#'
#' @return A matrix/dataframe where the NA values in the bin columns are replaced,
#'         and a new column `totalFeed` is added which represents the sum of feeds in all bins.
process_cur_synch <- function(cur_synch, total_bin) {
# Set the first row of cur_synch if it's NA.
# Use apply to go column by column and replace NA with the first non-NA value.
first_non_na <- apply(cur_synch[, 2:(ncol(cur_synch) - 1)],
2, function(x) x[which(!is.na(x))[1]])
cur_synch[1, 2:(ncol(cur_synch) - 1)] <- ifelse(is.na(cur_synch[1, 2:(ncol(cur_synch) - 1)]),
first_non_na,
cur_synch[1, 2:(ncol(cur_synch) - 1)])
# Replace NA values with the last observed non-NA value.
# Do this column by column.
cur_synch[, 2:(ncol(cur_synch) - 1)] <- apply(cur_synch[, 2:(ncol(cur_synch) - 1)], 2, na.locf)
# Add a new column calculating the total feed in all bins.
cur_synch$totalFeed <- rowSums(cur_synch[, 2:(total_bin + 1)], na.rm = TRUE)
return(cur_synch)
}
#' Process matrices and add derived columns.
#'
#' This function processes a list of matrices, adds several derived columns like total number of cows,
#' total bin occupied, and date, and then returns processed versions of the matrices.
#'
#' @param data_list A list of data frames to process.
#' @param min_feed_bin The minimum value of the feed bin.
#' @param max_feed_bin The maximum value of the feed bin.
#'
#' @return A list containing three processed lists of data frames: synch_master_cow2, synch_master_bin2, and synch_master_feed2.
matrix_process <- function(data_list, min_feed_bin, max_feed_bin) {
total_bin <- max_feed_bin - min_feed_bin + 1
results <- matrix_initialize(data_list, min_feed_bin, max_feed_bin)
synch_master_cow <- results$synch_master_cow
synch_master_bin <- results$synch_master_bin
synch_master_feed <- results$synch_master_feed
# create duplicates
synch_master_cow2 <- synch_master_cow
synch_master_bin2 <- synch_master_bin
synch_master_feed2 <- synch_master_feed
for (i in 1:length(synch_master_cow)) {
# calculate how many cows are present eating at each second
synch_master_cow[[i]]$total_cow_num <- rowSums(synch_master_cow[[i]][, 2:ncol(synch_master_cow[[i]])], na.rm = TRUE)
synch_master_cow[[i]]$total_bin_occupied <- synch_master_cow[[i]]$total_cow_num
synch_master_cow[[i]]$empty_bin_num <- total_bin - synch_master_cow[[i]]$total_bin_occupied
# delete the time when no cow is eating
records_to_keep <- which(synch_master_cow[[i]]$total_cow_num > 0)
synch_master_cow2[[i]] <- synch_master_cow[[i]][records_to_keep, ]
synch_master_bin2[[i]] <- synch_master_bin[[i]][records_to_keep, ]
synch_master_feed2[[i]] <- synch_master_feed[[i]][records_to_keep, ]
# add date
synch_master_cow2[[i]]$date <- date(synch_master_cow2[[i]]$Time)
synch_master_bin2[[i]]$date <- date(synch_master_bin2[[i]]$Time)
synch_master_feed2[[i]]$date <- date(synch_master_feed2[[i]]$Time)
# fill in feed amount at each second at each bin
synch_master_feed2[[i]] <- process_cur_synch(synch_master_feed2[[i]], total_bin)
}
return(list(synch_master_cow2 = synch_master_cow2,
synch_master_bin2 = synch_master_bin2,
synch_master_feed2 = synch_master_feed2))
}
results <- matrix_process(all.fed2, min_feed_bin, max_feed_bin)
feeding_synch_master_cow <- results$synch_master_cow
feeding_synch_master_bin <- results$synch_master_bin
feeding_synch_master_feed <- results$synch_master_feed
cache(feeding_synch_master_cow)
cache("feeding_synch_master_cow")
cache("feeding_synch_master_bin")
cache("feeding_synch_master_feed")
save(feeding_synch_master_cow, file = (here::here(paste0("data/results/", "which cows are present each second for feed.rda"))))
save(feeding_synch_master_bin, file = (here::here(paste0("data/results/", "which bins are occupied each second for feed.rda"))))
save(feeding_synch_master_feed, file = (here::here(paste0("data/results/", "how much feed left each bin.rda"))))
str(feeding_synch_master_bin)
str(feeding_synch_master_cow[1:2])
str(feeding_synch_master_bin[1:2])
str(feeding_synch_master_feed[1:2])
View(master_feeding)
colnames(master_feeding)
cur_data <- all.fed2[[1]]
sorted_data <- cur_data[order(cur_data$Bin, cur_data$Start, cur_data$End),]
sorted_data <- sorted_data[, c("Cow", "Bin", "Start", "End", "date")]
sorted_data <- cur_data[order(cur_data$Bin, cur_data$Start, cur_data$End),]
View(sorted_data)
sorted_data <- cur_data[order(cur_data$Bin, cur_data$Start, cur_data$End),]
sorted_data <- sorted_data[, c("Cow", "Bin", "Start", "End")]
sorted_data$date <- date(sorted_data$Start)
sorted_data <- cur_data[order(cur_data$Bin, cur_data$Start, cur_data$End),]
sorted_data <- sorted_data[, c("Cow", "Bin", "Start", "End")]
sorted_data$date <- date(sorted_data$Start)
bin_list <- sort(unique(sorted_data$Bin))
master_df <- data.frame()
cur_bin <- bin_list[1]
cur_data_bin <- sorted_data[which(sorted_data$Bin == cur_bin),]
next_start_list <- cur_data_bin$Start[2:nrow(cur_data_bin)]
next_cow_list <- cur_data_bin$Cow[2:nrow(cur_data_bin)]
cur_data_bin <- cur_data_bin[-nrow(cur_data_bin), ]
cur_data_bin$next_start <- next_start_list
cur_data_bin$next_cow <- next_cow_list
time_interval <- cur_data_bin$End %--% cur_data_bin$next_start
cur_data_bin$time_dif <- as.duration(time_interval)
replace_cutoff <- as.duration(paste0(replacement_threshold, "s"))
replacement_threshold = 26
cur_data_bin <- sorted_data[which(sorted_data$Bin == cur_bin),]
next_start_list <- cur_data_bin$Start[2:nrow(cur_data_bin)]
next_cow_list <- cur_data_bin$Cow[2:nrow(cur_data_bin)]
cur_data_bin <- cur_data_bin[-nrow(cur_data_bin), ]
cur_data_bin$next_start <- next_start_list
cur_data_bin$next_cow <- next_cow_list
time_interval <- cur_data_bin$End %--% cur_data_bin$next_start
cur_data_bin$time_dif <- as.duration(time_interval)
replace_cutoff <- as.duration(paste0(replacement_threshold, "s"))
cur_data_bin <- cur_data_bin[
which((cur_data_bin$time_dif <= replace_cutoff) &
(cur_data_bin$Cow != cur_data_bin$next_cow)),]
View(cur_data_bin)
colnames(cur_data_bin)
#' identify and recprd replacements for a single day. replacements are identified if the time interval
#' between the first cow leaving and the next cow entering is < 26s
#'
#' @param cur_data The data frame containing feeding/drinking data
#' @param replacement_threshold threshold for replacement behaviours in seconds.
#' the interval between the first cow leaving and the next cow entering
#' @return A data frame filtered by bins
record_replacement_1day <- function(cur_data, replacement_threshold = 26) {
sorted_data <- cur_data[order(cur_data$Bin, cur_data$Start, cur_data$End),]
sorted_data <- sorted_data[, c("Cow", "Bin", "Start", "End")]
sorted_data$date <- date(sorted_data$Start)
bin_list <- sort(unique(sorted_data$Bin))
master_df <- data.frame()
for (cur_bin in bin_list) {
cur_data_bin <- sorted_data[which(sorted_data$Bin == cur_bin),]
next_start_list <- cur_data_bin$Start[2:nrow(cur_data_bin)]
next_cow_list <- cur_data_bin$Cow[2:nrow(cur_data_bin)]
cur_data_bin <- cur_data_bin[-nrow(cur_data_bin), ]
cur_data_bin$next_start <- next_start_list
cur_data_bin$next_cow <- next_cow_list
time_interval <- cur_data_bin$End %--% cur_data_bin$next_start
cur_data_bin$time_dif <- as.duration(time_interval)
replace_cutoff <- as.duration(paste0(replacement_threshold, "s"))
cur_data_bin <- cur_data_bin[
which((cur_data_bin$time_dif <= replace_cutoff) &
(cur_data_bin$Cow != cur_data_bin$next_cow)),]
cur_data_bin <- cur_data_bin[, c("Cow", "Bin", "End", "date", "next_cow", "time_dif")]
# the time of replacement is the end time of the reactor cow's feeding event
colnames(cur_data_bin) <- c("Reactor_cow", "Bin", "Time", "date", "Actor_cow", "Bout_interval")
master_df <- rbind(master_df, cur_data_bin)
}
return(master_df)
}
#' identify and record replacements for all the dates in a list. replacements are identified if the time interval
#' between the first cow leaving and the next cow entering is < 26s
#'
#' @param data_list The data frame containing feeding/drinking data
#' @param replacement_threshold threshold for replacement behaviours in seconds.
#' the interval between the first cow leaving and the next cow entering
#'
#' @return a list of dataframes containing replacements for each day
record_replacement_allDay <- function(data_list, replacement_threshold) {
replacement_list_by_date <- list()
for (i in 1:length(data_list)) {
cur_data <- data_list[[i]]
replacement_list_by_date[[i]] <- record_replacement_1day(cur_data, replacement_threshold)
names(replacement_list_by_date)[i] <- names(data_list)[i]
}
return(replacement_list_by_date)
}
replacement_list_by_date <- record_replacement_allDay(all.fed2, replacement_threshold)
View(replacement_list_by_date)
cache("replacement_list_by_date")
str(replacement_list_by_date)
str(replacement_list_by_date[1:2])
#' identify and recprd replacements for a single day. replacements are identified if the time interval
#' between the first cow leaving and the next cow entering is < 26s
#'
#' @param cur_data The data frame containing feeding/drinking data
#' @param replacement_threshold threshold for replacement behaviours in seconds.
#' the interval between the first cow leaving and the next cow entering
#' @return A data frame filtered by bins
record_replacement_1day <- function(cur_data, replacement_threshold = 26) {
sorted_data <- cur_data[order(cur_data$Bin, cur_data$Start, cur_data$End),]
sorted_data <- sorted_data[, c("Cow", "Bin", "Start", "End")]
sorted_data$date <- date(sorted_data$Start)
bin_list <- sort(unique(sorted_data$Bin))
master_df <- data.frame()
for (cur_bin in bin_list) {
cur_data_bin <- sorted_data[which(sorted_data$Bin == cur_bin),]
next_start_list <- cur_data_bin$Start[2:nrow(cur_data_bin)]
next_cow_list <- cur_data_bin$Cow[2:nrow(cur_data_bin)]
cur_data_bin <- cur_data_bin[-nrow(cur_data_bin), ]
cur_data_bin$next_start <- next_start_list
cur_data_bin$next_cow <- next_cow_list
time_interval <- cur_data_bin$End %--% cur_data_bin$next_start
cur_data_bin$time_dif <- as.duration(time_interval)
replace_cutoff <- as.duration(paste0(replacement_threshold, "s"))
cur_data_bin <- cur_data_bin[
which((cur_data_bin$time_dif <= replace_cutoff) &
(cur_data_bin$Cow != cur_data_bin$next_cow)),]
cur_data_bin <- cur_data_bin[, c("Cow", "Bin", "End", "date", "next_cow", "time_dif")]
# the time of replacement is the end time of the reactor cow's feeding event
colnames(cur_data_bin) <- c("Reactor_cow", "Bin", "Time", "date", "Actor_cow", "Bout_interval")
master_df <- rbind(master_df, cur_data_bin)
}
return(master_df)
}
#' identify and record replacements for all the dates in a list. replacements are identified if the time interval
#' between the first cow leaving and the next cow entering is < 26s
#'
#' @param data_list The data frame containing feeding/drinking data
#' @param replacement_threshold time interval threshold between the first cow leaving and the next cow entering to be considered as a replacement behaviour
#' the interval between the first cow leaving and the next cow entering
#'
#' @return a list of dataframes containing replacements for each day
record_replacement_allDay <- function(data_list, replacement_threshold) {
replacement_list_by_date <- list()
for (i in 1:length(data_list)) {
cur_data <- data_list[[i]]
replacement_list_by_date[[i]] <- record_replacement_1day(cur_data, replacement_threshold)
names(replacement_list_by_date)[i] <- names(data_list)[i]
}
return(replacement_list_by_date)
}
#' Check if Actor Cow Has an Alibi on a Specific Day
#'
#' This function determines whether, at the end time of the reactor cow's feeding event,
#' the actor is eating/drinking from another bin. If that's the case,
#' the replacement is potentially invalid as the actor has an alibi.
#'
#' @param cur_replacement A data frame of replacement data for a given day.
#' @param cur_feed_wat A data frame containing feeding and drinking events for a given day.
#'
#' @return A data frame of filtered replacement events after checking alibi
check_alibi_daily <- function(cur_replacement, cur_feed_wat) {
cur_replacement$actor_at_another_bin <- 0
for (k in 1:nrow(cur_replacement)) {
cur_time <-cur_replacement$Time[k]
cur_actor <- cur_replacement$Actor_cow[k]
cur_actor_feed_wat <- cur_feed_wat[which((cur_feed_wat$Cow == cur_actor) & (cur_feed_wat$Start <= cur_time) & (cur_feed_wat$End >= cur_time)),]
if(nrow(cur_actor_feed_wat)>0) {
cur_replacement$actor_at_another_bin[k] <- 1
}
}
#delete the helper column
cur_replacement2 <- cur_replacement[which(cur_replacement$actor_at_another_bin == 0),]
cur_replacement2$actor_at_another_bin <- NULL
return(cur_replacement2)
}
#' Check if Actor Cow Has an Alibi Across Multiple Days
#'
#' This function applies the check_alibi_daily function across multiple days
#' to determine valid replacement events.
#'
#' @param replacement_list_by_date A list of data frames, each containing replacement data for a specific day.
#' @param all_comb2 A list of data frames, each containing feeding and drinking data for a specific day.
#'
#' @return A list of data frames with filtered replacement events.
check_alibi_all <- function(replacement_list_by_date, all_comb2) {
for (i in 1:length(all_comb2)) {
cur_replacement <- replacement_list_by_date[[i]]
cur_feed_wat <- all_comb2[[i]]
modified_cur_replacement <- check_alibi_daily(cur_replacement, cur_feed_wat)
replacement_list_by_date[[i]] <- modified_cur_replacement
}
return(replacement_list_by_date)
}
replacement_list_by_date <- check_alibi_all(replacement_list_by_date, all.comb2)
cache("replacement_list_by_date")
save(replacement_list_by_date, file = (here::here(paste0("data/results/", "Replacement_behaviour_by_date.rda"))))
master_feed_replacement_all <- merge_data(replacement_list_by_date)
View(replacement_list_by_date)
merge_data <- function(data_list) {
if (length(data_list) == 0) {
stop("The input list is empty!")
}
# Use do.call with rbind to efficiently concatenate all data frames in the list
master_data <- do.call(rbind, data_list)
return(master_data)
}
master_feed_replacement_all <- merge_data(replacement_list_by_date)
cache("master_feed_replacement_all")
save(master_feed_replacement_all, file = (here::here(paste0("data/results/", "master_feed_replacement_all.rda"))))
# load synchronicity matrix
load(here::here(paste0("data/results/", "which cows are present each second for feed.rda")))
load(here::here(paste0("data/results/", "which bins are occupied each second for feed.rda")))
load(here::here(paste0("data/results/", "how much feed left each bin.rda")))
