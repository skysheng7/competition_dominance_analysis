############################ Daylight saving change ########################
cur_year <- as.integer(year(cur_date))
cur_month <- as.integer(month(cur_date))
all.wat[[i]] = daylight_saving_adjust(all.wat[[i]], cur_date, cur_year, cur_month, daylight_saving_table)
#Adjusting start and end times to make R recognize the date and time format
all.wat[[i]]$Start=paste(rep(date,dim(all.wat[[i]])[1]),all.wat[[i]]$Start)
all.wat[[i]]$Start=ymd_hms(all.wat[[i]]$Start, tz=time_zone)
all.wat[[i]]$End=paste(rep(date,dim(all.wat[[i]])[1]),all.wat[[i]]$End)
all.wat[[i]]$End=ymd_hms(all.wat[[i]]$End, tz=time_zone)
}
#Adding dates as name
names(all.wat)[i]=date
}
return(all.wat)
}
#' Combine feeder and water data
#'
#' This function takes in lists containing feeder and water data and returns
#' a combined list where each element is the row-bound version of the
#' respective elements of the input lists.
#'
#' @param all.fed A list containing data frames of feeder data.
#' @param all.wat A list containing data frames of water data.
#'
#' @return A list combined feed and water data, grouped by dates
View(all.comb2)
View(all.fed2)
View(all.fed)
View(all.wat2)
657 + 3804
# combine data frame different dates into 1 master dataframe
# Calling the function for each data list:
master_feeding <- merge_data(all.fed2)
master_drinking <- merge_data(all.wat2)
master_comb <- merge_data(all.comb2)
save(master_feeding, file = (here::here(paste0("data/results/", "Cleaned_feeding_original_data_combined.rda"))))
save(master_drinking, file = (here::here(paste0("data/results/", "Cleaned_drinking_original_data_combined.rda"))))
save(master_comb, file = (here::here(paste0("data/results/", "Cleaned_feeding_drinking_original_data_combined.rda"))))
# get daily feed and water intake, duration, total visit summary
result <- merge_feed_water_summary(master_feeding, master_drinking, Insentec_warning,
feed_intake_low_bar, feed_intake_high_bar,
water_intake_low_bar, water_intake_high_bar)
Insentec_final_summary <- result$Insentec_final_summary
Insentec_warning <- result$Insentec_warning
View(Insentec_warning)
#' Summarize Feed or Water Data
#'
#' This function aggregates and summarizes the total daily intake, duration, and visits from a data frame
#' containing feed or water data for cows.
#'
#' @param data_frame A data frame containing at least the columns 'Intake', 'Duration', 'date', and 'Cow'.
#' @param type A character string, either 'Feeding' or 'Drinking', indicating the type of data to be processed.
#'
#' @return A list containing three data frames: 'intake', 'duration', and 'visits' each summarizing the respective metric for each cow and date.
summarize_feed_water_data <- function(data_frame, type = "Feeding") {
type <- capitalizeFirst(type)
# Ensure type is either "Feeding" or "Drinking"
if(!type %in% c("Feeding", "Drinking")) {
stop("The type should be either 'Feeding' or 'Drinking'.")
}
# Intake
intake <- aggregate(data_frame[, "Intake"], list(data_frame$date, data_frame$Cow), sum)
colnames(intake) <- c("date", "Cow", paste0(type, "_Intake(kg)"))
# Duration
duration <- aggregate(data_frame[, "Duration"], list(data_frame$date, data_frame$Cow), sum)
colnames(duration) <- c("date", "Cow", paste0(type, "_Duration(s)"))
# Visits
visits <- count(data_frame, vars = c("date", "Cow"))
colnames(visits) <- c("date", "Cow", paste0(type, "_Visits"))
# Return a list of the three summary data.frames
return(list(intake = intake,
duration = duration,
visits = visits))
}
#' Check Intake Levels for Cows
#'
#' This function checks if the intake (either feeding or drinking) for cows is above or below
#' the specified thresholds and updates the warning data accordingly.
#'
#' @param intake_data A data frame containing intake data for cows. Should have columns
#'   for date, cow, and the respective intake values.
#' @param warning_data A data frame containing warning data where the results are added.
#' @param type A character string specifying the type of intake, either "feeding" or "drinking".
#' @param limit A character string specifying if the function should check for "low" or "high" intake.
#' @param feed_intake_low_bar A numeric threshold for low feeding intake.
#' @param feed_intake_high_bar A numeric threshold for high feeding intake.
#' @param water_intake_low_bar A numeric threshold for low water intake.
#' @param water_intake_high_bar A numeric threshold for high water intake.
#'
#' @return A data frame (`warning_data`) updated with any abnormal intakes.
check_intake <- function(intake_data, warning_data, type = c("feeding", "drinking"),
limit = c("low", "high"), feed_intake_low_bar = feed_intake_low_bar,
feed_intake_high_bar = feed_intake_high_bar,
water_intake_low_bar = water_intake_low_bar,
water_intake_high_bar = water_intake_high_bar) {
type <- deCapitalizeFirst(type)
# Define thresholds based on type and limit
thresholds <- list(
feeding = list(low = feed_intake_low_bar, high = feed_intake_high_bar),
drinking = list(low = water_intake_low_bar, high = water_intake_high_bar)
)
threshold <- thresholds[[type]][[limit]]
colname <- ifelse(type == "feeding", "Feeding_Intake(kg)", "Drinking_Intake(kg)")
# Subset data based on threshold
if (limit == "low") {
abnormal_intake <- intake_data[which(intake_data[[colname]]< threshold), ]
} else if (limit == "high") {
abnormal_intake <- intake_data[which(intake_data[[colname]]> threshold), ]
}
if (nrow(abnormal_intake) > 0) {
abnormal_intake$comb_str <- paste("Cow ", abnormal_intake$Cow, ", ", abnormal_intake[[colname]], "kg")
for (i in 1:nrow(warning_data)) {
cur_date <- warning_data$date[i]
cur_day_abnormal <- abnormal_intake[which(abnormal_intake$date == cur_date), ]
cur_day_abnormal_cow <- sort(unique(cur_day_abnormal$comb_str))
middle_name <- ifelse(type == "feeding", "feed", "water")
colname <- paste0(limit, "_daily_", middle_name, "_intake_cows")
warning_data[[colname]][i] <- paste(unlist(cur_day_abnormal_cow), collapse = "; ")
}
}
return(warning_data)
}
#' Merge Feed and Water Summary Data
#'
#' This function first summarizes the feed and water data for each cow on a daily basis.
#' It then checks and updates the warnings for cows with abnormally high or low intakes.
#' Finally, it merges the summaries and warnings together to return a final data set.
#'
#' @param master_f A data frame containing feed data.
#' @param master_d A data frame containing drink data.
#' @param Insentec_warning A data frame containing the initial warning data.
#' @param feed_intake_low_bar A numeric threshold for low feeding intake.
#' @param feed_intake_high_bar A numeric threshold for high feeding intake.
#' @param water_intake_low_bar A numeric threshold for low water intake.
#' @param water_intake_high_bar A numeric threshold for high water intake.
#'
#' @return A list containing two data frames: 'Insentec_final_summary' which summarizes
#'   the feed and water data, and 'Insentec_warning' which contains the updated warnings.
merge_feed_water_summary <- function(master_f = NULL, master_d = NULL, Insentec_warning,
feed_intake_low_bar, feed_intake_high_bar,
water_intake_low_bar, water_intake_high_bar) {
# Initializing lists
list_to_join <- list()
# get feed and drinking summary for each day for each cow
if (!is.null(master_f)) {
feed_summary <- summarize_feed_water_data(master_f, type = "Feeding")
# feeding
feeding_intake <- feed_summary$intake
feeding_duration <- feed_summary$duration
feeding_visits <- feed_summary$visits
# check for low & high feeding intake
Insentec_warning <- check_intake(feeding_intake, Insentec_warning, type = "feeding",
limit = "low", feed_intake_low_bar, feed_intake_high_bar,
water_intake_low_bar, water_intake_high_bar)
Insentec_warning <- check_intake(feeding_intake, Insentec_warning, type = "feeding",
limit = "high", feed_intake_low_bar, feed_intake_high_bar,
water_intake_low_bar, water_intake_high_bar)
list_to_join <- c(list_to_join, list(feeding_intake, feeding_duration, feeding_visits))
}
if (!is.null(master_d)) {
drink_summary <- summarize_feed_water_data(master_d, type = "Drinking")
# drinking
drinking_intake <- drink_summary$intake
drinking_duration <- drink_summary$duration
drinking_visits <- drink_summary$visits
# check for low & high drinking intake
Insentec_warning <- check_intake(drinking_intake, Insentec_warning, type = "drinking",
limit = "low", feed_intake_low_bar, feed_intake_high_bar,
water_intake_low_bar, water_intake_high_bar)
Insentec_warning <- check_intake(drinking_intake, Insentec_warning, type = "drinking",
limit = "high", feed_intake_low_bar, feed_intake_high_bar,
water_intake_low_bar, water_intake_high_bar)
list_to_join <- c(list_to_join, list(drinking_intake, drinking_duration, drinking_visits))
}
if (length(list_to_join) > 0) {
Insentec_final_summary <- join_all(list_to_join, by = c("date", "Cow"))
Insentec_final_summary <- Insentec_final_summary[order(Insentec_final_summary$date, Insentec_final_summary$Cow),]
Insentec_final_summary[is.na(Insentec_final_summary)] <- 0 # replace NA with 0
save(Insentec_warning, file = (here::here(paste0("data/results/", "Insentec_warning.rda"))))
save(Insentec_final_summary, file = (here::here(paste0("data/results/", "Feeding and drinking analysis.rda"))))
}
return(list(Insentec_final_summary = ifelse(exists("Insentec_final_summary"), Insentec_final_summary, NULL),
Insentec_warning = Insentec_warning))
}
results <- generate_warning_df(data_source = "feed and water", all_feed = all.fed,
all_water = all.wat, high_feed_dur_threshold,
high_water_dur_threshold, min_feed_bin, max_feed_bin,
min_wat_bin, max_wat_bin, bin_id_add,
total_cow_expt, low_visit_threshold, time_zone)
Insentec_warning <- results$Insentec_warning
all.fed2 <- results$feed
all.wat2 <- results$water
all.comb2 <- results$comb
# combine data frame different dates into 1 master dataframe
# Calling the function for each data list:
master_feeding <- merge_data(all.fed2)
master_drinking <- merge_data(all.wat2)
master_comb <- merge_data(all.comb2)
save(master_feeding, file = (here::here(paste0("data/results/", "Cleaned_feeding_original_data_combined.rda"))))
save(master_drinking, file = (here::here(paste0("data/results/", "Cleaned_drinking_original_data_combined.rda"))))
save(master_comb, file = (here::here(paste0("data/results/", "Cleaned_feeding_drinking_original_data_combined.rda"))))
# get daily feed and water intake, duration, total visit summary
result <- merge_feed_water_summary(master_feeding, master_drinking, Insentec_warning,
feed_intake_low_bar, feed_intake_high_bar,
water_intake_low_bar, water_intake_high_bar)
Insentec_final_summary <- result$Insentec_final_summary
Insentec_warning <- result$Insentec_warning
View(Insentec_warning)
load("C:/Users/skysheng/OneDrive - UBC/University of British Columbia/Research/PhD Project/Lameness one year trial/Analysis/Dominance_competition_density/10month_elo_competition_density/results/round3_2022June/rda/dominance_needed_rda.Rda")
# store all intermediate files
cache(all.fed2)
exists("all.fed2")
cache("all.fed2")
all.wat2
cache("all.wat2")
cache("all.comb2")
cache("master_feeding")
cache("master_drinking")
cache("master_comb")
cache("Insentec_final_summary")
cache("Insentec_warning")
cache("all.fed2")
View(dominance_needed_rda)
names(dominance_needed_rda)
View(dominance_needed_rda)
#' Create a time sequence from start to end, by seconds
#'
#' @param cur_data A data frame containing feeding data, or drinking data or both.
#' @return A vector of time sequence.
create_time_sequence <- function(cur_data) {
total_start <- min(cur_data$Start)
total_end <- max(cur_data$End)
dateTime_seq <- seq(total_start, total_end, by = "sec")
return(dateTime_seq)
}
#' create MATRIX1: empty matrix preperation: CowID X Time for which cow is eating/drinking
#' create a matrix where x axis contains cow ID, and y axis contains time (every seconds)
#'
#' @param cur_data A data frame containing feeding data, or drinking data or both.
#' @param dateTime_seq A vector of time sequence.
#' @return A matrix of Time and cowID.
prepare_time_cow_matrix <- function(cur_data, dateTime_seq) {
cow_list <- sort(unique(cur_data$Cow))
col_num <- length(cow_list) + 1
synch_master_cow <- data.frame(matrix(0, length(dateTime_seq), col_num))
colnames(synch_master_cow) <- c("Time", cow_list)
synch_master_cow$Time <- dateTime_seq
return(synch_master_cow)
}
#' create MARTRIX2: empty matrix preperation: Time X CowID for which bin the cow is at
#'
#' @param cow_time_matrix A matrix of CowID and Time.
#' @return A matrix of Time and CowID.
prepare_time_bin_matrix <- function(cow_time_matrix) {
return(cow_time_matrix)
}
#' create MATRIX3: Time X Bin for how much feed is at each bin at each second
#'
#' @param dateTime_seq A vector of time sequence.
#' @param min_feed_bin Minimum feeder bin value to keep.
#' @param max_feed_bin Maximum feeder bin value to keep.
#' @return A matrix of Time and Feed amount in each bin.
prepare_time_feed_matrix <- function(dateTime_seq, min_feed_bin, max_feed_bin) {
bin_list <- seq(min_feed_bin, max_feed_bin, by = 1)
col_num <- length(bin_list) + 1
synch_master_feed <- data.frame(matrix(NA, length(dateTime_seq), col_num))
colnames(synch_master_feed) <- c("Time", bin_list)
synch_master_feed$Time <- dateTime_seq
return(synch_master_feed)
}
#' Generate Synchronization Matrices for Feed/water Data
#'
#' This function takes a list of feed data and creates synchronization matrices for time-cow,
#' time-bin, and time-feed based on each list element.
#'
#' @param data_list A list of feed / water data frames grouped by date.
#'
#' @return A list containing three lists of matrices:
#'         synch_master_cow, synch_master_bin, synch_master_feed.
empty_synch_matrix <- function(data_list) {
date_list <- names(data_list)
synch_master_cow <- list()
synch_master_bin <- list()
synch_master_feed <- list()
for (y in 1:length(data_list)) {
cur_data <- data_list[[y]]
cur_data <- cur_data[order(cur_data$Start, cur_data$End), ]
dateTime_seq <- create_time_sequence(cur_data)
cow_time_matrix <- prepare_time_cow_matrix(cur_data, dateTime_seq)
time_bin_matrix <- prepare_time_bin_matrix(cow_time_matrix)
time_feed_matrix <- prepare_time_feed_matrix(dateTime_seq, min_feed_bin, max_feed_bin)
synch_master_cow[[y]] <- cow_time_matrix
synch_master_bin[[y]] <- time_bin_matrix
synch_master_feed[[y]] <- time_feed_matrix
# rename the list name
names(synch_master_cow)[y] <- names(data_list)[y]
names(synch_master_bin)[y] <- names(data_list)[y]
names(synch_master_feed)[y] <- names(data_list)[y]
}
return(list(synch_master_cow = synch_master_cow,
synch_master_bin = synch_master_bin,
synch_master_feed = synch_master_feed))
}
results <- empty_synch_matrix(all.fed2)
feeding_synch_master_cow <- results$synch_master_cow
feeding_synch_master_bin <- results$synch_master_bin
feeding_synch_master_feed <- results$synch_master_feed
View(feeding_synch_master_bin)
View(feeding_synch_master_cow)
View(feeding_synch_master_feed)
View(feeding_synch_master_cow[["2020-07-15"]])
View(feeding_synch_master_feed)
View(feeding_synch_master_feed[["2020-07-15"]])
View(all.fed2)
View(all.fed2[["2020-07-15"]])
install.packages("zoo")
#' Create a time sequence from start to end, by seconds
#'
#' @param cur_data A data frame containing feeding data, or drinking data or both.
#' @return A vector of time sequence.
create_time_sequence <- function(cur_data) {
total_start <- min(cur_data$Start)
total_end <- max(cur_data$End)
dateTime_seq <- seq(total_start, total_end, by = "sec")
return(dateTime_seq)
}
#' create MATRIX1: empty matrix preperation: CowID X Time for which cow is eating/drinking
#' create a matrix where x axis contains cow ID, and y axis contains time (every seconds)
#'
#' @param cur_data A data frame containing feeding data, or drinking data or both.
#' @param dateTime_seq A vector of time sequence.
#' @return A matrix of Time and cowID.
prepare_time_cow_matrix <- function(cur_data, dateTime_seq) {
cow_list <- sort(unique(cur_data$Cow))
col_num <- length(cow_list) + 1
synch_master_cow <- data.frame(matrix(0, length(dateTime_seq), col_num))
colnames(synch_master_cow) <- c("Time", cow_list)
synch_master_cow$Time <- dateTime_seq
return(synch_master_cow)
}
#' create MARTRIX2: empty matrix preperation: Time X CowID for which bin the cow is at
#'
#' @param cow_time_matrix A matrix of CowID and Time.
#' @return A matrix of Time and CowID.
prepare_time_bin_matrix <- function(cow_time_matrix) {
return(cow_time_matrix)
}
#' create MATRIX3: Time X Bin for how much feed is at each bin at each second
#'
#' @param dateTime_seq A vector of time sequence.
#' @param min_feed_bin Minimum feeder bin value to keep.
#' @param max_feed_bin Maximum feeder bin value to keep.
#' @return A matrix of Time and Feed amount in each bin.
prepare_time_feed_matrix <- function(dateTime_seq, min_feed_bin, max_feed_bin) {
bin_list <- seq(min_feed_bin, max_feed_bin, by = 1)
col_num <- length(bin_list) + 1
synch_master_feed <- data.frame(matrix(NA, length(dateTime_seq), col_num))
colnames(synch_master_feed) <- c("Time", bin_list)
synch_master_feed$Time <- dateTime_seq
return(synch_master_feed)
}
#' Generate empty Synchronization Matrices for Feed/water Data
#'
#' This function takes a list of feed data and creates synchronization matrices for time-cow,
#' time-bin, and time-feed based on each list element.
#'
#' @param data_list A list of feed / water data frames grouped by date.
#' @param min_feed_bin Minimum feeder bin value to keep.
#' @param max_feed_bin Maximum feeder bin value to keep.
#' @return A list containing three lists of matrices:
#'         synch_master_cow, synch_master_bin, synch_master_feed.
empty_synch_matrix <- function(data_list, min_feed_bin, max_feed_bin) {
date_list <- names(data_list)
synch_master_cow <- list()
synch_master_bin <- list()
synch_master_feed <- list()
for (y in 1:length(data_list)) {
cur_data <- data_list[[y]]
cur_data <- cur_data[order(cur_data$Start, cur_data$End), ]
dateTime_seq <- create_time_sequence(cur_data)
cow_time_matrix <- prepare_time_cow_matrix(cur_data, dateTime_seq)
time_bin_matrix <- prepare_time_bin_matrix(cow_time_matrix)
time_feed_matrix <- prepare_time_feed_matrix(dateTime_seq, min_feed_bin, max_feed_bin)
synch_master_cow[[y]] <- cow_time_matrix
synch_master_bin[[y]] <- time_bin_matrix
synch_master_feed[[y]] <- time_feed_matrix
# rename the list name
names(synch_master_cow)[y] <- names(data_list)[y]
names(synch_master_bin)[y] <- names(data_list)[y]
names(synch_master_feed)[y] <- names(data_list)[y]
}
return(list(synch_master_cow = synch_master_cow,
synch_master_bin = synch_master_bin,
synch_master_feed = synch_master_feed))
}
#' Initialize and Process Synchronization Matrices
#'
#' This function initializes synchronization matrices and processes feed/water data
#' to populate the matrices based on each list element.
#' It process MATRIX1 (synch_master_cow): Time X CowID for which cow is eating/drinking
#' AND MARTRIX2 (synch_master_bin): Time X CowID for which bin the cow is at
#' AND MATRIX3 (synch_master_feed): Time X Bin for how much feed/watr is at each bin at each second
#'
#' @param data_list A list of data frames.
#' @param min_feed_bin Minimum value of the feed bin.
#' @param max_feed_bin Maximum value of the feed bin.
#'
#' @return A list containing three matrices:
#'         synch_master_cow, synch_master_bin, synch_master_feed.
matrix_initialize <- function(data_list, min_feed_bin, max_feed_bin) {
results <- empty_synch_matrix(data_list, min_feed_bin, max_feed_bin)
synch_master_cow <- results$synch_master_cow
synch_master_bin <- results$synch_master_bin
synch_master_feed <- results$synch_master_feed
# go through every single day
for (y in 1:length(data_list)) {
cur_data <- data_list[[y]]
cur_data <- cur_data[order(cur_data$Start, cur_data$End), ]
cow_list <- sort(unique(cur_data$Cow))
bin_list <- seq(min_feed_bin, max_feed_bin, by = 1)
### Process MATRIX1 (synch_master_cow): Time X CowID for which cow is eating/drinking
### AND MARTRIX2 (synch_master_bin): Time X CowID for which bin the cow is at
### AND MATRIX3 (synch_master_feed): Time X Bin for how much feed/watr is at each bin at each second
# go through the feed or water datasheet, mark down a "1" on the time, if the cow is feeding/drinking at that second
for (o in 1:nrow(cur_data)) {
cur_cow <- cur_data$Cow[o]
index_cow <- match(cur_cow, cow_list)+1
cur_start <- cur_data$Start[o]
cur_end <- cur_data$End[o]
cur_dur <- cur_data$Duration[o]
cur_bin <- cur_data$Bin[o]
index_bin <- match(cur_bin, bin_list) + 1
start_weight <- cur_data$Startweight[o]
end_weight <- cur_data$Endweight[o]
start_row_number <- which(synch_master_cow[[y]]$Time == cur_start)
end_row_number <- which(synch_master_cow[[y]]$Time == cur_end)
weight_list <- round(seq(start_weight, end_weight, length.out = (end_row_number - start_row_number + 1)), digits = 1)
# process matrix 1, time X CowID on cow
synch_master_cow[[y]][(start_row_number:end_row_number) , index_cow] <- 1
# process matrix 2, time X CowID on bin number
synch_master_bin[[y]][(start_row_number:end_row_number) , index_cow] <- cur_bin
# process matrix 3, time X Bin
synch_master_feed[[y]][(start_row_number:end_row_number), index_bin] <- weight_list
}
}
return(list(synch_master_cow = synch_master_cow,
synch_master_bin = synch_master_bin,
synch_master_feed = synch_master_feed))
}
#' Process matrices and add derived columns.
#'
#' This function processes a list of matrices, adds several derived columns like total number of cows,
#' total bin occupied, and date, and then returns processed versions of the matrices.
#'
#' @param data_list A list of data frames to process.
#' @param min_feed_bin The minimum value of the feed bin.
#' @param max_feed_bin The maximum value of the feed bin.
#'
#' @return A list containing three processed lists of data frames: synch_master_cow2, synch_master_bin2, and synch_master_feed2.
matrix_process <- function(data_list, min_feed_bin, max_feed_bin) {
total_bin <- max_feed_bin - min_feed_bin + 1
results <- matrix_initialize(data_list, min_feed_bin, max_feed_bin)
synch_master_cow <- results$synch_master_cow
synch_master_bin <- results$synch_master_bin
synch_master_feed <- results$synch_master_feed
# create duplicates
synch_master_cow2 <- synch_master_cow
synch_master_bin2 <- synch_master_bin
synch_master_feed2 <- synch_master_feed
for (i in 1:length(synch_master_cow)) {
# calculate how many cows are present eating at each second
synch_master_cow[[i]]$total_cow_num <- rowSums(synch_master_cow[[i]][, 2:ncol(synch_master_cow[[i]])], na.rm = TRUE)
synch_master_cow[[i]]$total_bin_occupied <- synch_master_cow[[i]]$total_cow_num
synch_master_cow[[i]]$empty_bin_num <- total_bin - synch_master_cow[[i]]$total_bin_occupied
# delete the time when no cow is eating
records_to_keep <- which(synch_master_cow[[i]]$total_cow_num > 0)
synch_master_cow2[[i]] <- synch_master_cow[[i]][records_to_keep, ]
synch_master_bin2[[i]] <- synch_master_bin[[i]][records_to_keep, ]
synch_master_feed2[[i]] <- synch_master_feed[[i]][records_to_keep, ]
# add date
synch_master_cow2[[i]]$date <- date(synch_master_cow2[[i]]$Time)
synch_master_bin2[[i]]$date <- date(synch_master_bin2[[i]]$Time)
synch_master_feed2[[i]]$date <- date(synch_master_feed2[[i]]$Time)
}
return(list(synch_master_cow2 = synch_master_cow2,
synch_master_bin2 = synch_master_bin2,
synch_master_feed2 = synch_master_feed2))
}
process_feed_data <- function(feed_data, total_bin) {
# Set the first row of feed_data if it's NA.
# Use apply to go column by column and replace NA with the first non-NA value.
first_non_na <- apply(feed_data[, 2:(ncol(feed_data) - 1)], 2, function(x) x[which(!is.na(x))[1]])
feed_data[1, 2:(ncol(feed_data) - 1)] <- ifelse(is.na(feed_data[1, 2:(ncol(feed_data) - 1)]), first_non_na, feed_data[1, 2:(ncol(feed_data) - 1)])
# Replace NA values with the last observed non-NA value.
# Do this column by column.
feed_data[, 2:(ncol(feed_data) - 1)] <- apply(feed_data[, 2:(ncol(feed_data) - 1)], 2, na.locf)
# Add a new column calculating the total feed in all bins.
feed_data$totalFeed <- rowSums(feed_data[, 2:(total_bin + 1)], na.rm = TRUE)
return(feed_data)
}
# Call the function
synch_master_feed2 <- process_feed_data(synch_master_feed2, total_bin)
test <- all.fed2[1:2]
View(test)
results <- matrix_process(test, min_feed_bin, max_feed_bin)
feeding_synch_master_cow <- results$synch_master_cow
feeding_synch_master_bin <- results$synch_master_bin
feeding_synch_master_feed <- results$synch_master_feed
View(feeding_synch_master_bin)
View(feeding_synch_master_cow)
View(feeding_synch_master_feed)
View(feeding_synch_master_bin[["2020-07-15"]])
